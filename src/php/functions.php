<?php

// -------------------------------------------------------------------- ΕΞΑΓΩΓΗ RTF ΠΕΡΙΕΧΟΜΕΝΟΥ ---

/** Κλείνει το RTF αρχείο, αν απαιτείται, με εξαγωγή του κατάλληλου κειμένου.
 * Το RTF αρχείο κλείνει με το χαρακτήρα '}', αλλά ένα script μπορεί να ενσωματώνει μεγάλο αριθμό
 * δικαιολογητικών τα οποία δεν πρέπει να κλείσουν το RTF γιατί δεν γνωρίζουν ότι ακολουθούν και άλλα
 * δικαιολογητικά.
 * <p>Π.χ. η δαπάνη εξάγει και δικαιολογητικό σύμβασης, αλλά η σύμβαση εξάγεται και μόνη της. Οπότε
 * μόνο αν βρισκόμαστε στο PHP script που κλήθηκε (και όχι σε κάποιο που εισήχθηκε με require) κλείνει
 * το RTF αρχείο.
 * @param string $file Το όνομα αρχείου του script που αιτείται κλείσιμο του RTF αρχείου */
function rtf_close($file) {
	// Επιστρέφει το PHP script που κλήθηκε πρώτο.
	$a = get_required_files();
	if ($file == $a[0]) echo "\n\n\n}";
}

/** Εξάγει τις ιδιότητες της ενότητας κειμένου ενός στρατιωτικού εγγράφου. */
function start_35_20() { ?>

\sectd\sbkodd\pgwsxn11906\pghsxn16838\marglsxn1984\margrsxn1134\margtsxn1700\margbsxn1134\facingp\margmirror

<?php }


// ------------------------------------------------------------------- ΜΟΡΦΟΠΟΙΗΣΗ ΔΟΜΩΝ ΓΙΑ RTF ---

/** Μαρκάρει ειδικούς χαρακτήρες.
 * Τυχόν χαρακτήρες στο κείμενο που παίζουν ειδικό ρόλο στο πρότυπο (specification) του RTF τους
 * τους κάνει escape με το χαρακτήρα backslash.
 * @param type $a Ένα κείμενο
 * @return type Έλεγχος του $a για χαρακτήρες ελέγχου στο RTF Spec και αντικατάστασή τους */
function rtf($a) { return str_replace(array('\\', '{', '}'), array('\\\\', '\{', '\}'), $a); }

/** Επιστρέφει την παράμετρο σε ευρώ, αν είναι αριθμός, ειδάλλως πυροδοτεί σφάλμα.
 * @param int|float $a Ο αριθμός
 * @param bool $zero Αν είναι true, ο αριθμός 0 επιστρέφει '0,00 €', ειδάλλως επιστρέφει null
 * @return string Ο αριθμός στη μορφή '1.234,10 €' */
function euro($a, $zero = false) {
	$a = num($a);
	if (!$a) return $zero ? '0,00 ' : null;
	else return sprintf('%01.2f ', $a);
}

/** Επιστρέφει την παράμετρο σε ποσοστό, αν είναι αριθμός, ειδάλλως πυροδοτεί σφάλμα.
 * @param int|float $a Ο αριθμός
 * @return float Ο αριθμός ακολουθούμενος από το '%', ή αν είναι 0, το 0 */
function percent($a) {
	$a = num($a);
	return !$a ? '0' : "$a%";
}

/** Επιστρέφει την παράμετρο αν είναι αριθμός, ειδάλλως πυροδοτεί σφάλμα.
 * @param int|float $a Ο αριθμός
 * @return float Ο αριθμός */
function num($a) {
	if (is_numeric($a)) return (float) $a;
	if ($a) trigger_error("Η τιμή '<b>$a</b>' θα έπρεπε να είναι αριθμός");
}


// ---------------------------------------------------------------- ΕΞΥΠΝΗ ΜΕΤΑΤΡΟΠΗ ΣΕ ΚΕΦΑΛΑΙΑ ---

/** Μετατρέπει ένα κείμενο σε κεφαλαία, αφαιρώντας τον τονισμό.
 * @param string $s Το κείμενο εισόδου, π.χ. '1ος Λόχος'
 * @return string Το κείμενο εισόδου με όλα τα γράμματα κεφαλαία, χωρίς τονισμό, π.χ. '1ΟΣ ΛΟΧΟΣ' */
function strtoupperg($s) {
	static $pre = array('’', 'Έ', 'Ή', 'Ί', 'Ό', 'Ύ', 'Ώ', 'ς');
	static $aft = array('Α', 'Ε', 'Η', 'Ι', 'Ο', 'Υ', 'Ω', 'Σ');
	return str_replace($pre, $aft, strtoupper($s));
}

/** Μετατρέπει ένα κείμενο σε κεφαλαία, αφαιρώντας τον τονισμό και με σεβασμό σε αριθμούς.
 * @param string $s Το κείμενο εισόδου, π.χ. '1ος Λόχος'
 * @return string Το κείμενο εισόδου με όλα τα γράμματα κεφαλαία, χωρίς τονισμό, π.χ. '1ος ΛΟΧΟΣ' */
function strtouppergn($s) {
	return preg_replace_callback('/(\W|^)\D\w+/', function($m) { return strtoupperg($m[0]); }, $s);
}


// --------------------------------------------------------------------------- ΕΛΛΗΝΙΚΗ ΑΡΙΘΜΗΣΗ ---

/** Επιστρέφει την ελληνική αναπαράσταση ενός ακέραιου αριθμού.
 * @param int $n Ακέραιος αριθμός από το 1 μέχρι το 999
 * @return string Η ελληνική αναπαράσταση του αριθμού (π.χ. στ για το 6) */
function greeknum($n) {
	if ($n < 1 || $n > 999) trigger_error("Για να μεταφραστεί το '<b>$n</b>' σε ελληνική αρίθμηση πρέπει να είναι ακέραιος και να ανήκει στο [1, 999]");
	static $m = array(null, 'α', 'β', 'γ', 'δ', 'ε', 'στ', 'ζ', 'η', 'θ');
	static $d = array(null, 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', '\u991  ');
	static $e = array(null, 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', '\u993  ');
	return $e[floor($n / 100)] . $d[floor($n / 10) % 10] . $m[$n % 10];
}


// ------------------------------------------------------------------------------------- ΚΛΙΣΕΙΣ ---

/** Μετατρέπει όλες τις λέξεις της πρότασης από ονομαστική σε άλλη πτώση του ενικού.
 * Δεν υποστηρίζει τρελά πράγματα, απλά ανιχνεύει την κατάληξη μιας μιας λέξης και την αντικαθιστά.
 * Οι λέξεις πρέπει να είναι με μικρά γράμματα ή τουλάχιστον η κατάληξη των λέξεων. Επίσης πρέπει
 * να είναι τουλάχιστον 2 γράμματα.
 * @param string $a Το κείμενο με λέξεις στην ονομαστική ενικού
 * @param int $w Μετατροπή σε (0) ονομαστική, (1) γενική, (2) αιτιατική, (3) κλιτική του ενικού
 * @return string Το $a με τις λέξεις στη σωστή πτώση του ενικού */
function inflectPhrase($a, $w) {
	return !$w ? $a : preg_replace_callback('/[Α-Ωα-ω’-Ώά-ώΐΰΪΫ]{3,}|\d+(ος|η|ο)/',
		function($m) use($w) { return inflection($m[0], $w); }, $a);
}

/** Μετατρέπει την ονομαστική ενός αρσενικού ή θηλυκού σε άλλη πτώση του ενικού.
 * Δεν υποστηρίζει τρελά πράγματα, απλά ανιχνεύει την κατάληξη και την αντικαθιστά. Η λέξη πρέπει
 * να είναι με μικρά γράμματα ή τουλάχιστον η κατάληξη της λέξης. Επίσης πρέπει να είναι τουλάχιστον
 * 2 γράμματα.
 * @param string $o Η ονομαστική ενικού ενός αρσενικού ή θηλυκού αντικειμένου ή επιθέτου (μια λέξη)
 * @param int $w Μετατροπή σε (0) ονομαστική, (1) γενική, (2) αιτιατική, (3) κλιτική του ενικού
 * @return string Το $o στη σωστή πτώση του ενικού */
function inflection($o, $w) {
	$b = substr($o, -2);
	if ($b == 'ος' && $w == 1) return substr($o, 0, -1) . 'υ';
	elseif ($b == 'ός' && $w == 1) return substr($o, 0, -2) . 'ού';
	elseif ($w >= 2 && $w <= 3 && ($b == 'ος' || $b == 'ός') ||
					$w >= 1 && $w <= 3 && strpos('ης ής ας άς ες ές υς ύς ', "$b ") !== false)
		return substr($o, 0, -1);
  elseif ($w == 1 && strpos('ηήαάωώ', substr($o, -1)) !== false)
		return $o . 'ς';
	return $o;
}

/** Επιστρέφει το γένος ενός ουσιαστικού ή επιθέτου.
 * Επειδή μπορεί να υπάρξει κείμενο 'Αδάμου Νικόλαος' και 'Αδάμου Φωτεινή', αναζητάται το γένος σε
 * κάθε λέξη διαδοχικά, μέχρι να βρεθεί.
 * <p>Είναι πιθανό το γένος να επιστραφεί εσφαλμένο ή να μην προσδιοριστεί τελικά.
 * @param string $txt Κείμενο το οποίο χωρίζεται σε λέξεις και αναζητάται το γένος ξεκινώντας από
 * την πρώτη λέξη και μέχρι να βρεθεί
 * @return int 0 αν βρεθεί λέξη αρσενικού γένους, 1 αν βρεθεί θυλικού, 2 αν βρεθεί ουδέτερου και -1
 * αν δε μπορεί να προσδιοριστεί */
function gender($txt) {
	$text = explode(' ', $txt);
	foreach($text as $txt)
		switch(strtolower(substr($txt, -1))) {
			case 'ς':
			case 'σ': return 0;
			case 'α': // Εκτός από θυλικό θα μπορούσε να είναι και ουδέτερο
			case 'ά': // π.χ. προσάναμα
			case 'η':
			case 'ή': return 1;
			case 'ο':
			case 'ό':
			case 'ι':
			case 'ί': return 2;
		}
	return -1;
}

/** Επιστρέφει το άρθρο ενός ουσιαστικού ή επιθέτου.
 * @param int $gender 0 για αρσενικό γένος, 1 για θυλικό, 2 για ουδέτερο και -1 για απροσδιόριστο
 * @param int $inflection 0 για ονομαστική, 1 για γενική, 2 για αιτιατική και 3 για κλιτική
 * @param bool $on false για άρθρο και true για 'στου', 'στον', 'στης', 'στην', 'στο'
 * @return string Το άρθρο */
function article($gender, $inflection, $on = false) {
	if ($on)
		switch($gender) {
			case 1:
				switch($inflection) {
					case 1: return 'στης';
					case 2: return 'στην';
				}
				break;
			case 2:
				switch($inflection) {
					case 1: return 'στου';
					case 2: return 'στο';
				}
				break;
			default:	// αρσενικά και απροσδιόριστα
				switch($inflection) {
					case 1: return 'στου';
					case 2: return 'στον';
				}
				break;
		}
	else
		switch($gender) {
			case 1:
				switch($inflection) {
					case 0: return 'η';
					case 1: return 'της';
					case 2: return 'την';
				}
				break;
			case 2:
				switch($inflection) {
					case 0: return 'το';
					case 1: return 'του';
					case 2: return 'το';
				}
				break;
			default:	// αρσενικά και απροσδιόριστα
				switch($inflection) {
					case 0: return 'ο';
					case 1: return 'του';
					case 2: return 'τον';
				}
				break;
		}
}


// ----------------------------------------------------------------------------------- ΠΡΟΣΩΠΙΚΟ ---

/** Επιστρέφει ένα string με το ονοματεπώνυμο ενός Στρατιωτικού.
 * @param array $a Tα στοιχεία του Στρατιωτικού
 * @return string Το ονοματεπώνυμο του Στρατιωτικού στη μορφή 'Τχης (ΜΧ) Γκέσος Παύλος' */
function person($a) { return rtf($a['Βαθμός'] . ' ' . $a['Ονοματεπώνυμο']); }

/** Επιστρέφει ένα string με το ονοματεπώνυμο ενός Στρατιωτικού.
 * @param array $a Tα στοιχεία του Στρατιωτικού
 * @param int $c Αν είναι 0, ο Στρατιωτικός είναι στην ονομαστική κλίση. Αν είναι 1 είναι στη γενική.
 * Αν είναι 2 είναι στην αιτιατική. Αν είναι 3 είναι στην κλιτική.
 * @return string Το ονοματεπώνυμο του Στρατιωτικού στη δοσμένη πτώση, έχοντας τη μορφή π.χ.
 * 'Τχη (ΜΧ) Γκέσου Παύλου του 3ου ΛΜΧ', με τη Μονάδα να εξάγεται μόνο αν υπάρχει */
function personi($a, $c) {
	return inflectPhrase(person($a), $c) . (isset($a['Μονάδα']) ? " {$a['Μονάδα']}" : null);
}

/** Από τη σύντμηση ενός στρατιωτικού βαθμού, επιστρέφει το βαθμό ολογράφως.
 * @param string $a Η σύντμηση του βαθμού, στη μορφή 'ΕΠΟΠ Δνέας (ΜΧ)'
 * @return string Ο βαθμός ολογράφως, στη μορφή 'ΕΠΟΠ Δεκανέας (ΜΧ)' */
function fullrank($a) {
	$find = array(
		'Στρτης', 'Δνεας', 'Δνέας', 'Λχιας', 'Λχίας', 'Επχιας', 'Επχίας', 'Αλχιας', 'Αλχίας',
		'Ανθστης', 'Ανθστής', 'Ανθλγος', 'Ανθλγός', 'Ανθλχος', 'Υπλγος', 'Υπλγός', 'Υπλχος',
		'Λγος', 'Λγός', 'Ιλχος', 'Ίλχος', 'Τχης', 'Επχος', 'Ανχης', 'Σχης', 'Τξχος', 'Υπτγος',
		'Αντγος', 'Στγος', 'Στγός'
	);
	$replace = array(
		'Στρατιώτης', 'Δεκανέας', 'Δεκανέας', 'Λοχίας', 'Λοχίας', 'Επιλοχίας', 'Επιλοχίας',
		'Αρχιλοχίας', 'Αρχιλοχίας', 'Ανθυπασπιστής', 'Ανθυπασπιστής',
		'Ανθυπολοχαγός', 'Ανθυπολοχαγός', 'Ανθυπίλαρχος', 'Υπολοχαγός', 'Υπολοχαγός', 'Υπίλαρχος',
		'Λοχαγός', 'Λοχαγός', 'Ίλαρχος', 'Ίλαρχος', 'Ταγματάρχης', 'Επίλαρχος', 'Αντισυνταγματάρχης',
		'Συνταγματάρχης', 'Ταξίαρχος', 'Υποστράτηγος', 'Αντιστράτηγος', 'Στρατηγός', 'Στρατηγός'
	);
	return str_replace($find, $replace, $a);
}


// ---------------------------------------------------------------------------------------- ΙΒΑΝ ---

/** Ελέγχει αν ένας τραπεζικός λογαριασμός ΙΒΑΝ είναι ελληνικός και έγκυρος.
 * @param string $iban Ο λογαριασμός ΙΒΑΝ
 * @return string Ο λογαριασμός IBAN αν είναι ελληνικός και έγκυρος, αλλιώς πυροδοτεί σφάλμα */
function iban($iban) {
	$iban = str_replace(' ', '', $iban);
	if (is_greek_iban($iban) && is_valid_iban($iban)) return $iban;
	trigger_error($iban ? "Το IBAN '<b>$iban</b>' δεν είναι ελληνικό και έγκυρο" : 'Δεν δώθηκε έγκυρο ελληνικό ΙΒΑΝ');
}

/** Ελέγχει αν ένας τραπεζικός λογαριασμός ΙΒΑΝ συμφωνεί με το ελληνικό πρότυπο.
 * Δεν κάνει έλεγχο εγκυρότητας στον IBAN. Απλά ελέγχει αν τα ψηφία του συμφωνούν με αυτά που έχουν
 * καθοριστεί για τους ελληνικούς IBAN.
 * @param string $iban Ο λογαριασμός ΙΒΑΝ χωρίς κενά, μόνο με χαρακτήρες 0-9Α-Ζ
 * @return bool Ο λογαριασμός IBAN είναι ελληνικός αλλά πιθανόν μη έγκυρος */
function is_greek_iban($iban) { return preg_match('/GR\d{25}/', $iban); }

/** Ελέγχει αν ένας τραπεζικός λογαριασμός ΙΒΑΝ συμφωνεί με το γενικό πρότυπο.
 * Δεν κάνει έλεγχο εγκυρότητας στον IBAN. Απλά ελέγχει αν τα ψηφία του συμφωνούν με αυτά που έχουν
 * καθοριστεί για τους IBAN.
 * @param string $iban Ο λογαριασμός ΙΒΑΝ χωρίς κενά, μόνο με χαρακτήρες 0-9Α-Ζ
 * @return bool Είναι λογαριασμός IBAN, αλλά πιθανόν μη έγκυρος */
function is_iban($iban) { return preg_match('/[A-Z]{2}\d{2}[A-Z0-9]{1,30}/', $iban); }

/** Ελέγχει αν ένας τραπεζικός λογαριασμός ΙΒΑΝ είναι έγκυρος.
 * Πριν την εκτέλεση, θα πρέπει ένας από τους is_iban(), is_greek_iban() να έχει επιστρέψει true.
 * <p>Ένας λογαριασμός IBAN αποτελείται:
 * <ul><li>Από 2 κεφαλαία λατινικά γράμματα (Α-Ζ) της χώρας. Στην Ελλάδα GR.
 * <li>Από 2 αριθμούς (0-9) ελέγχου εγκυρότητας.
 * <li>Μέχρι 30 χαρακτήρες, αριθμούς ή κεφαλαία λατινικά γράμματα (0-9 Α-Ζ) που καθορίζονται
 * διαφορετικά σε κάθε χώρα και αποτελούν τον Basic Bank Account Number (BBAN). Στην Ελλάδα
 *  συγκεκριμένα είναι 23 αριθμοί (0-9):
 * <ul><li>Από 3 αριθμούς (0-9) που δηλώνουν την τράπεζα.
 * <li>Από 4 αριθμούς (0-9) που δηλώνουν το υποκατάστημα της τράπεζας.
 * <li>Από 16 αριθμούς (0-9) που δηλώνουν το λογαριασμό στην τράπεζα.</ul></ul>
 * <p>Ο αριθμός ελέγχου εγκυρότητας προκύπτει ως εξής:
 * <ul><li>Δημιουργούμε έναν κείμενο που αποτελείται από τον BBAN, τον κωδικό της χώρας και το '00'
 * που αντικαθιστά τους αριθμούς ελέγχου εγκυρότητας που δεν έχουμε υπολογίζει ακόμα. Δηλαδή πάμε
 * τους πρώτους 4 χαρακτήρες του ΙΒΑΝ στο τέλος και για αριθμούς ελέγχου εγκυρότητας βάζουμε '00'.
 * <li>Μετατρέπουμε κάθε γράμμα του κειμένου σε διψήφιο αριθμό, αφαιρώντας από τον ASCII χαρακτήρα
 * το 55. Έτσι κάθε χαρακτήρας ξεκινάει από το 10.
 * <li>Υπολογίζουμε το υπόλοιπο της διαίρεσης του παραπάνω κειμένου, που πλέον είναι αριθμός, από το
 * 97.
 * <li>Αφαιρούμε το υπόλοιπο της διαίρεσης που βρήκαμε παραπάνω από το 98.
 * <li>Το αποτέλεσμα είναι ο αριθμός ελέγχου εγκυρότητας.</ul>
 * <p>Ο έλεγχος εγκυρότητας πραγματοποιείται ως εξής:
 * <ul><li>Δημιουργούμε έναν κείμενο που αποτελείται από τον BBAN, τον κωδικό της χώρας και τους
 * αριθμούς ελέγχου εγκυρότητας. Δηλαδή πάμε τους πρώτους 4 χαρακτήρες του ΙΒΑΝ στο τέλος.
 * <li>Μετατρέπουμε κάθε γράμμα του κειμένου σε διψήφιο αριθμό, αφαιρώντας από τον ASCII χαρακτήρα
 * το 55. Έτσι κάθε χαρακτήρας ξεκινάει από το 10.
 * <li>Υπολογίζουμε το υπόλοιπο της διαίρεσης του παραπάνω κειμένου, που πλέον είναι αριθμός, από το
 * 97.
 * <li>Αν το αποτέλεσμα είναι 1, ο ΙΒΑΝ είναι έγκυρος.</ul>
 * @param string $iban Ο λογαριασμός ΙΒΑΝ χωρίς κενά, μόνο με χαρακτήρες 0-9Α-Ζ
 * @return bool Ο λογαριασμός IBAN είναι έγκυρος
 * @see is_iban(), is_greek_iban() */
function is_valid_iban($iban) {
	$trg = '';
	foreach(str_split(substr($iban, 4) . substr($iban, 0, 4)) as $c)
		if (ord($c) > 64) $trg .= ord($c) - 55; else $trg .= $c;
	return bcmod($trg, 97) == 1;
}

/** Επιστρέφει την τράπεζα στην οποία ανήκει ένας λογαριασμός IBAN.
 * Η τράπεζα πρέπει να δραστηριοποιείται στην Ελλάδα.
 * @param string $iban Ο λογαριασμός ΙΒΑΝ, ο οποίος πρέπει να είναι ελληνικός
 * @param bool $trigger Πυροδοτεί σφάλμα αν ο ΙΒΑΝ δεν αντιστοιχεί σε καμία τράπεζα
 * @return string|null Η επώνυμία της τράπεζας στην οποία ανήκει ο λογαριασμός */
function bank($iban, $trigger = true) {
	switch((int) substr($iban, 4, 3)) {
		case  10: return 'ΤΡΑΠΕΖΑ ΤΗΣ ΕΛΛΑΔΟΣ Α.Ε.';
		case  11: return 'ΕΘΝΙΚΗ ΤΡΑΠΕΖΑ ΤΗΣ ΕΛΛΑΔΟΣ Α.Ε.';
		case  14: return 'ALPHA BANK';
		case  16: return 'ATTICA BANK ΑΝΩΝΥΜΗ ΤΡΑΠΕΖΙΚΗ ΕΤΑΙΡΕΙΑ';
		case  17: return 'ΤΡΑΠΕΖΑ ΠΕΙΡΑΙΩΣ Α.Ε.';
		case  26: return 'ΤΡΑΠΕΖΑ EUROBANK ERGASIAS A.E.';
		case  34: return 'ΕΠΕΝΔΥΤΙΚΗ ΤΡΑΠΕΖΑ ΕΛΛΑΔΟΣ Α.Ε.';
		case  39: return 'ΜΠΕ ΕΝ ΠΕ ΠΑΡΙΜΠΑ ΣΕΚΙΟΥΡΙΤΙΣ ΣΕΡΒΙΣΙΣ';
		case  40: return 'FCA BANK GmbH';
		case  50: return 'ΤΡΑΠΕΖΑ ΣΑΝΤΕΡΑΤ ΙΡΑΝ';
		case  56: return 'AEGEAN BALTIC BANK Α.Τ.Ε.';
		case  57: return 'CREDICOM CONSUMER FINANCE ΤΡΑΠΕΖΑ Α.Ε.';
		case  58: return 'UNION DE CREDITOS INMOBILIARIOS S.A. ESTABLECIMIENTO FINANCIER';
		case  59: return 'OPEL BANK GmbH';
		case  61: return 'FCE BANK PLC';
		case  64: return 'THE ROYAL BANK OF SCOTLAND PLC';
		case  69: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΧΑΝΙΩΝ Συν. Π.Ε.';
		case  71: return 'HSBC BANK PLC';
		case  72: return 'UNICREDIT BANK AG';
		case  73: return 'ΤΡΑΠΕΖΑ ΚΥΠΡΟΥ ΔΗΜΟΣΙΑ ΕΤΑΙΡΕΙΑ ΛΤΔ';
		case  75: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΗΠΕΙΡΟΥ Συν. Π.Ε.';
		case  81: return 'ΜΠΑΝΚ ΟΦ ΑΜΕΡΙΚΑ ΝΑ';
		case  84: return 'CITIBANK EUROPE PLC';
		case  87: return 'ΠΑΓΚΡΗΤΙΑ ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ Συν. Π.Ε.';
		case  88: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ Ν. ΕΒΡΟΥ Συν. Π.Ε.';
		case  89: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΚΑΡΔΙΤΣΑΣ Συν. Π.Ε.';
		case  91: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΘΕΣΣΑΛΙΑΣ Συν. Π.Ε.';
		case  92: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΠΕΛΟΠΟΝΝΗΣΟΥ Συν. Π.Ε.';
		case  94: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΠΙΕΡΙΑΣ "ΟΛΥΜΠΙΑΚΗ ΠΙΣΤΗ" Συν. Π.Ε.';
		case  95: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ ΔΡΑΜΑΣ Συν. Π.Ε.';
		case  97: return 'ΤΑΜΕΙΟ ΠΑΡΑΚΑΤΑΘΗΚΩΝ & ΔΑΝΕΙΩΝ';
		case  99: return 'ΣΥΝΕΤΑΙΡΙΣΤΙΚΗ ΤΡΑΠΕΖΑ Ν. ΣΕΡΡΩΝ Συν. Π.Ε.';
		case 102: return 'VOLKSWAGEN BANK GMBH';
		case 105: return 'BMW AUSTRIA BANK GmbH';
		case 106: return 'MERCEDES-BENZ BANK POLSKA S.A.';
		case 107: return 'GREEK BRANCH OF KEDR OPEN JOINTSTOCK COMPANY COMMERCIAL B';
		case 109: return 'T.C ZIRAAT BANKASI A.S';
		case 111: return 'DEUTSCHE BANK AG';
		case 113: return 'CREDIT SUISSE (LUXEMBOURG) S.A.';
		case 114: return 'FIMBANK PLC.';
		case 115: return 'HSH NORDBANK AG';
		case 116: return 'PROCREDIT BANK (BULGARIA) EAD';
		default: if ($trigger) trigger_error("Ο IBAN '<b>$iban</b>' αντιστοιχεί σε μη καταχωρημένη τράπεζα.");
	}
}

/** Εκτελείται από το περιβάλλον Java προκειμένου να αποκτήσει πληροφορίες για ένα λογαριασμό IBAN.
 * Εξάγει πληροφορίες οι οποίες επιστρέφουν στο περιβάλλον Java και εμφανίζονται σε ένα παράθυρο.
 * @param string $iban Ο λογαριασμός ΙΒΑΝ χωρίς κενά, μόνο με χαρακτήρες 0-9Α-Ζ */
function iban_gui($iban) {
	if (!is_iban($iban) || !is_valid_iban($iban))
		echo $iban ? "O $iban δεν είναι έγκυρος ΙΒΑΝ" : 'Μη έγκυρος IBAN';
	else {
		echo "O $iban είναι έγκυρος ΙΒΑΝ\n";
		if (!is_greek_iban($iban)) echo 'Ο ΙΒΑΝ δεν είναι ελληνικός και δεν υποστηρίζεται.';
		else {
			echo "O IBAN είναι ελληνικός (GR)\n";
			$bank = bank($iban, false);
			if (!isset($bank)) echo 'Ο IBAN αντιστοιχεί σε τράπεζα που δεν υπάρχει.';
			else {
				echo "Η τράπεζα είναι $bank (κωδικός: " . substr($iban, 4, 3) . ")\n";
				echo 'Το υποκατάστημα της τράπεζας έχει κωδικό ' . substr($iban, 7, 4) . "\n";
				echo 'Ο αριθμός λογαριασμού είναι ' . substr($iban, 11);
			}
		}
	}
}


// -------------------------------------------------------------------------------------- ΧΡΟΝΟΣ ---

/** Ελέγχει αν η ημερομηνία δόθηκε σωστά και την επιστρέφει, αλλιώς πυροδοτεί σφάλμα.
 * @param string $a Ημερομηνία στη μορφή '31 Δεκ 19'
 * @return string Το $a αν η ημερομηνία είναι στη σωστή μορφή */
function chk_date($a) { get_timestamp_from_date($a); return $a; }

/** Επιστρέφει το πιο πρόσφατο timestamp τιμολογίου ή σύμβασης.
 * @param array $ar Λίστα τιμολογίων ή συμβάσεων
 * @return int|null Το timestamp του πιο πρόσφατου τιμολογίου/σύμβασης ή null αν δεν υπάρχουν
 * τιμολόγια/συμβάσεις ή δεν έχει οριστεί η ταυτότητα κανενός από αυτά */
function get_newer_timestamp($ar) {
	$a = null;
	foreach($ar as $i)
		if (isset($i['Ημερομηνία']) && $a < $i['Ημερομηνία']) $a = $i['Ημερομηνία'];
	return $a;
}


// ----------------------------------------------------------------------- ΑΝ ΕΙΝΑΙ NULL ΚΑΝΕ... ---

/** Επιστρέφει το στοιχείο ενός array αν υπάρχει.
 * @param array $ar Το array
 * @param string|int $key Το κλειδί του στοιχείου του array
 * @return mixed|null Η τιμή του στοιχείου με το δοσμένο κλειδί ή null */
function ifexist($ar, $key) { if (isset($ar[$key])) return $ar[$key]; }
/** Επιστρέφει το στοιχείο ενός array αν υπάρχει ή αν ισχύει μια δευτερεύουσα σχέση.
 * @param bool $exp Μια δευτερεύουσα λογική σχέση
 * @param array $ar Το array
 * @param string|int $key Το κλειδί του στοιχείου του array
 * @return mixed|null Η τιμή του στοιχείου με το δοσμένο κλειδί ή null */
function ifexist2($exp, $ar, $key) { if ($exp || isset($ar[$key])) return $ar[$key]; }
/** Επιστρέφει το στοιχείο ενός array αν υπάρχει, αλλιώς επιστρέφει κάτι άλλο.
 * @param array $ar Το array
 * @param string|int $key Το κλειδί του στοιχείου του array
 * @param mixed $else Μια εναλλακτική τιμή αν δεν είναι να επιστραφεί η κανονική
 * @return mixed|null Η τιμή του στοιχείου με το δοσμένο κλειδί ή null */
function orelse($ar, $key, $else) { return isset($ar[$key]) ? $ar[$key] : $else; }
/** Επιστρέφει το στοιχείο ενός array αν υπάρχει ή αν ισχύει μια δευτερεύουσα σχέση, αλλιώς επιστρέφει κάτι άλλο.
 * @param bool $exp Μια δευτερεύουσα λογική σχέση
 * @param array $ar Το array
 * @param string|int $key Το κλειδί του στοιχείου του array
 * @param mixed $else Μια εναλλακτική τιμή αν δεν είναι να επιστραφεί η κανονική
 * @return mixed Η τιμή του στοιχείου με το δοσμένο κλειδί ή $else */
function orelse2($exp, $ar, $key, $else) { return $exp || isset($ar[$key]) ? $ar[$key] : $else; }


// ---------------------------------------------------------------- ΥΠΟΛΟΓΙΣΜΟΙ ΑΞΙΩΝ ΤΙΜΟΛΟΓΙΩΝ ---

/** Υπολογίζει τα αθροίσματα των αξιών λίστας τιμολογίων.
 * @param array $invoices Η λίστα τιμολογίων. Πρέπει να περιέχει τουλάχιστον ένα τιμολόγιο.
 * @param array $keys Τα κλειδιά των αξιών για τις οποίες θα υπολογιστούν τα αθροίσματά τους, π.χ.
 * 'Καθαρή Αξία'. Αν είναι null, υπολογίζονται τα αθροίσματα όλων των αξιών.
 * @return array Τα αθροίσματα των τιμών, όλων των τιμολογίων της δοσμένης λίστας */
function calc_sum_of_invoices_prices($invoices, $keys = null) {
	if (!$keys) $keys = array_keys($invoices[0]['Τιμές']);	// Λήψη όλων των κλειδιών των αξιών από το πρώτο τιμολόγιο
	$b = array_fill_keys($keys, 0);		// Αρχικοποίηση των αθροισμάτων με τιμή 0
	foreach($invoices as $invoice) {
		$price = $invoice['Τιμές'];
		foreach($keys as $key)
			$b[$key] += $price[$key];
	}
	return $b;
}

/** Ρυθμίζει μια ομάδα τιμών ώστε να έχουν ένα συγκεκριμένο άθροισμα.
 * Αν ένα ποσοστό μεταφράζεται σε μία αξία που στρογγυλοποιείται σε 2 δεκαδικά ψηφία, και ταυτόχρονα
 * αυτό το ποσοστό αναλύεται σε επιμέρους ποσοστά, τότε αν οι αντίστοιχες αξίες των επιμέρους ποσοστών
 * στρογγυλοποιηθούν στα 2 δεκαδικά ψηφία και προστεθούν, η συνολική τους αξία, ενδέχεται λόγω
 * σφαλμάτων στρογγυλοποίησης να μην είναι ίδια με την αξία που αντιστοιχούσε στο αρχικό ποσοστό.
 * Για το λόγο αυτό, οι επιμέρους αξίες τροποποιούνται ελαφρώς κατά 0.01 προκειμένου το άθροισμά τους
 * να είναι ίδιο με την αξία του αρχικού ποσοστού.
 * @param array $in Οι αξίες των επιμέρους ποσοστών χωρίς στρογγυλοποίηση
 * @param float $desirableSum Το επιθυμητό άθροισμα των παραπάνω αξιών, μετά τη στρογγυλοποίηση
 * @return array Οι αξίες των επιμέρους ποσοστών μετά τη στρογγυλοποίηση */
function adjust_partials($in, $desirableSum) {
	$sum = 0;
	$remainders = array(); $out = array();
	foreach($in as $key => $term) {
		$term_new = round($term, 2);
		$remainders[] = array($key, $term_new - $term);
		$out[$key] = $term_new;
		$sum += $term;
	}
	$remainder = round(($sum - $desirableSum) * 100);
	if ($remainder) {
		$comparator = function($v1, $v2) {
			if ($v1[1] < $v2[1]) return -1;
			if ($v1[1] > $v2[1]) return 1;
			return 0;
		};
		usort($remainders, $comparator);
		if ($remainder > 0)
			for ($z = 0; $z < $remainder; ++$z)
				$out[$remainders[count($remainders) - 1 - $z][0]] -= 0.01;
		else
			for ($z = 0; $z < -$remainder; ++$z)
				$out[$remainders[$z][0]] += 0.01;
	}
	return $out;
}


// --------------------------------------------- ΚΑΤΗΓΟΡΙΑ ΤΙΜΟΛΟΓΙΩΝ, ΣΥΜΒΑΣΕΩΝ ΚΑΙ ΔΙΑΓΩΝΙΣΜΩΝ ---

/** Υπάρχει τιμολόγιο παροχής υπηρεσιών.
 * @param array $invoices Λίστα με τιμολόγια
 * @return boolean Υπάρχει τουλάχιστον ένα τιμολόγιο παροχής υπηρεσιών στη λίστα τιμολογίων */
function has_service_category($invoices) {
	foreach($invoices as $invoice)
		if (!is_supply($invoice['Κατηγορία'])) return true;
	return false;
}

/** Επιστρέφει ένα array με λίστες τιμολογίων χωριστά για προμήθειες και για υπηρεσίες.
 * @param array $invoices Λίστα με τιμολόγια
 * @return array Το στοιχείο 0 είναι array με όλα τα τιμολόγια που αφορούν υπηρεσίες. Το στοιχείο 1
 * είναι array με όλα τα τιμολόγια που αφορούν προμήθειες. Αν δεν υπάρχουν αντίστοιχα τιμολόγια, δεν
 * υπάρχει και το αντίστοιχο στοιχείο. */
function get_invoices_by_category($invoices) {
	$b = array();
	foreach($invoices as $invoice)
		$b[(int) is_supply($invoice['Κατηγορία'])][] = $invoice;
	return $b;
}

/** Επιστρέφει true αν η κατηγορία του τιμολογίου είναι προμήθειας.
 * @param string $category Η κατηγορία του τιμολογίου
 * @return boolean Η κατηγορία του τιμολογίου είναι προμήθεια */
function is_supply($category) { return $category == 'Προμήθεια υλικών' || $category == 'Προμήθεια υγρών καυσίμων'; }

/** Ο τύπος της σύμβασης ή του διαγωνισμού.
 * @param array $invoices Ομάδα τιμολογίων της ίδιας σύμβασης ή του ίδιου διαγωνισμού
 * @return string Αν η σύμβαση ή ο διαγωνισμός είναι έργο, τότε επιστρέφεται 'έργο'. Αν το σύνολο
 * των καθαρών αξιών των τιμολογίων προμήθειας είναι μεγαλύτερο από το σύνολο των καθαρών αξιών των
 * τιμολογίων υπηρεσιών, επιστρέφεται 'προμήθεια' αλλιώς επιστρέφεται 'υπηρεσία'. */
function get_invoices_category($invoices) {
	global $data;
	if ($data['Έργο']) return 'έργο';
	$b = array(0, 0);
	foreach($invoices as $invoice)
		$b[(int) is_supply($invoice['Κατηγορία'])] += $invoice['Τιμές']['Καθαρή Αξία'];
	return $b[1] >= $b[0] ? 'προμήθεια' : 'υπηρεσία';
}


// ------------------------------------------------------------------------- ΠΛΗΡΟΦΟΡΙΕΣ ΝΑΙ/ΟΧΙ ---

/** Έλεγχος αν υπάρχει στη δαπάνη απευθείας ανάθεση.
 * Μπορεί να υπάρχει διαγωνισμός, αλλά ο έλεγχος αφορά αν υπάρχουν συμβάσεις εκτός διαγωνισμών.
 * @return bool Υπάρχει στη δαπάνη απευθείας ανάθεση */
function has_direct_assignment() {
	global $data;
	if ($data['Τιμές']['Καθαρή Αξία'] > 2500)
		foreach($data['Τιμολόγια'] as $invoice)
			if (!isset($invoice['Σύμβαση']['Διαγωνισμός'])) return true;
	return false;
}

/** Οι πράξεις της δαπάνης κοινοποιούνται στο διαδίκτυο.
 * Πρέπει να έχει εκτελεστεί προηγουμένως η explode_order($data['Απόφαση Ανάληψης Υποχρέωσης']) */
function published() {
	global $data;
	return isset($data['Απόφαση Ανάληψης Υποχρέωσης']['ΑΔΑ']);
}

/** Το έγγραφο που εξάγεται είναι ολόκληρη δαπάνη. */
function is_expenditure() {
	global $output;
	return $output === 'δαπάνη';
}

/** Επιστρέφει αν η αποσφράγιση των προσφορών θα γίνει σε δυο φάσεις.
 * @param array $tender Ο διαγωνισμός
 * @return boolean Η αποσφράγιση των προσφορών θα γίνει σε 2 φάσεις */
function has_2_unseals($tender) { return isset($tender['Χρόνος Αποσφράγισης Οικονομικών Προσφορών']); }


// ---------------------------------------------------------------------------- ΛΙΣΤΑ ΣΕ ΠΡΟΤΑΣΗ ---

/** Επιστρέφει σε κείμενο, όλα τα ονόματα ενός array με στοιχεία.
 * @param array $a Η λίστα με τα στοιχεία. Δεν μπορεί να είναι άδεια.
 * @param string $key Το κλειδί, για κάθε στοιχείο, με το όνομα του στοιχείου
 * @return string Τα ονόματα των στοιχείων του array χωρισμένα με ',' εκτός από τα τελευταία 2 που
 * είναι χωρισμένα με 'και' */
function get_names_key($a, $key) {
	return get_names(array_values(array_map(function($b) use($key) { return $b[$key]; }, $a)));
}

/** Επιστρέφει σε κείμενο, όλα τα ονόματα ενός array.
 * @param array $a Η λίστα με τα ονόματα. Δεν μπορεί να είναι άδεια.
 * @return string Τα ονόματα του array χωρισμένα με ',' εκτός από τα τελευταία 2 που είναι χωρισμένα
 * με 'και' */
function get_names($a) {
	$n = count($a);
	$r = '';
	for ($z = 0; $z < $n - 2; ++$z)
		$r .= "{$a[$z]}, ";
	if ($n > 1) $r .= "{$a[$n - 2]} και ";
	$r .= $a[$n - 1];
	return $r;
}


// ---------------------------------------------------------- ΠΛΗΡΟΦΟΡΙΕΣ ΠΡΟΜΗΘΕΥΤΗ ΚΑΙ ΜΟΝΑΔΑΣ ---

/** Επιστρέφει τα ταχυδρομικά στοιχεία της Μονάδας.
 * @return string Η έδρα, η διεύθυνση, το τηλέφωνο και ο ΤΚ της Μονάδας */
function get_unit_info() {
	global $data;
	$a = 'διεύθυνση: ' . $data['Έδρα'];
	if (isset($data['Διεύθυνση'])) $a .= ', ' . $data['Διεύθυνση'];
	if (isset($data['Τηλέφωνο'])) $a .= ', τηλέφωνο: ' . $data['Τηλέφωνο'];
	if (isset($data['Τ.Κ.'])) $a .= ', Τ.Κ. ' . $data['Τ.Κ.'];
	return $a;
}

/** Επιστρέφει τα ταχυδρομικά στοιχεία της Μονάδας.
 * @return string Η έδρα, η διεύθυνση και ο ΤΚ της Μονάδας */
function get_unit_address() {
	global $data;
	$a = $data['Έδρα'];
	if (isset($data['Διεύθυνση'])) $a .= ', ' . $data['Διεύθυνση'];
	if (isset($data['Τ.Κ.'])) $a .= ', ' . $data['Τ.Κ.'];
	return $a;
}

/** Επιστρέφει τα σημαντικά στοιχεία ενός οικονομικού φορέα.
 * @param array $contractor Ο οικονομικός φορέας
 * @return string Η επωνυμία, το ΑΦΜ, η διεύθυνση, το τηλέφωνο και το e-mail του οικονομικού φορέα */
function get_contractor_full_info($contractor) {
	$r = "{$contractor['Επωνυμία']}, ΑΦΜ: {$contractor['ΑΦΜ']}";
	if (isset($contractor['Τηλέφωνο'])) $r .= ", τηλέφωνο: {$contractor['Τηλέφωνο']}";
	if (isset($contractor['Διεύθυνση'])) $r .= ", διεύθυνση: {$contractor['Διεύθυνση']}";
	if (isset($contractor['e-mail'])) $r .= ", e-mail: {$contractor['e-mail']}";
	return $r;
}

/** Επιστρέφει τα διακριτικά στοιχεία ενός οικονομικού φορέα.
 * @param array $contractor Ο οικονομικός φορέας
 * @return string Η επωνυμία και το ΑΦΜ του οικονομικού φορέα */
function get_contractor_id($contractor) { return "{$contractor['Επωνυμία']} (ΑΦΜ: {$contractor['ΑΦΜ']})"; }


// ------------------------------------------------------------------- ΣΥΝΑΡΤΗΣΕΙΣ ΑΡΧΙΚΟΠΟΙΗΣΗΣ ---

/** Ελέγχει για την ορθότητα του έτους.
 * Το τετραψήφιο έτος πρέπει να είναι από 1900 έως και 2 χρόνια μεταγενέστερα του τρέχοντος έτους.
 * <p>Αν το διψήφιο έτος είναι μεταγενέστερο του τρέχοντος + 2 χρόνια, λαμβάνεται ως 19ΧΧ, ειδάλλως
 * ως 20ΧΧ.
 * @param int $year Διψήφιος ή τετραψήφιος αριθμός του έτους
 * @return int Τετραψήφιος αριθμός του έτους */
function get_year($year) {
	$n = strlen($year);
	$curyear = date('Y');
	if ($n == 2) return $year + (2000 + $year > $curyear + 3 ? 1900 : 2000);
	else if ($n == 4 && $year >= 1900 && $year < $curyear + 3) return (int) $year;
}

/** Επιστρέφει τον αριθμό του μήνα από το σύντομο όνομα του μήνα.
 * @param string $month Σύντμηση του μήνα π.χ. 'Νοε'
 * @return int|null Ο αριθμός του μήνα, π.χ. 11 ή null αν δε δόθηκε έγκυρος μήνας */
function get_month($month) {
	$months = array(
		'Ιαν' => 1, 'Φεβ' => 2, 'Μαρ' => 3, 'Απρ' => 4, 'Μαι' => 5, 'Ιουν' => 6,
		'Ιουλ' => 7, 'Αυγ' => 8, 'Σεπ' => 9, 'Οκτ' => 10, 'Νοε' => 11, 'Δεκ' => 12,
		'Μάρ' => 3, 'Μαϊ' => 5, 'Μάι' => 5, 'Ιούν' => 6, 'Ιούλ' => 7, 'Αύγ' => 8, 'Νοέ' => 11);
	if (isset($months[$month])) return $months[$month];
}

/** Παίρνει μια χρονική στιγμή σε κείμενο και επιστρέφει timestamp.
 * @param string|int $a Ημερομηνία της μορφής '31 23:59 Δεκ 19' κατά την είσοδο και timestamp μετά
 * την έξοδο */
function make_timestamp(& $a) {
	$m = null;
	if (preg_match('/^(\d{1,2}) (\d{1,2})\:(\d\d) (.{3,4}) (\d\d|\d\d\d\d)$/', $a, $m)) {
		array_shift($m);
		$m[3] = get_month($m[3]);
		$m[4] = get_year($m[4]);
		if (is_int($m[4]) && checkdate($m[3], $m[0], $m[4])
				&& $m[1] >= 0 && $m[1] < 24 && $m[2] >= 0 && $m[2] < 60)
			$a = mktime($m[1], $m[2], 0, $m[3], $m[0], $m[4]);
	} else trigger_error(($a ? "Το '<b>$a</b>' δεν είναι χρονική στιγμή" : 'Οι χρονικές στιγμές πρέπει να δίνονται') . " στη μορφή π.χ. '20 21:34 Νοε 2005'");
}

/** Παίρνει μια χρονική στιγμή σε κείμενο και αν υπάρχει, επιστρέφει timestamp.
 * Με την επιστροφή της συνάρτησης το στοιχείο $ar[$key] έχει το timestamp της δοσμένης χρονικής στιγμής.
 * @param array $ar Ένα array με κάποιο στοιχείο του να είναι το κείμενο με τη χρονική στιγμή της
 * μορφής '31 23:59 Δεκ 19'
 * @param string|int $key Το κλειδί του στοιχείου του array */
function make_timestamp_if_exists(& $ar, $key) {
	if (isset($ar[$key])) make_timestamp($ar[$key]);
}

/** Παίρνει μια ημερομηνία σε κείμενο και επιστρέφει το timestamp της.
 * @param string $a Ημερομηνία της μορφής '31 Δεκ 19'
 * @return int timestamp της ημερομηνίας */
function get_timestamp_from_date($a) {
	$m = explode(' ', $a, 3);
	if (count($m) == 3) {
		$m[1] = get_month($m[1]);
		$m[2] = get_year($m[2]);
		if (is_int($m[2]) && checkdate($m[1], $m[0], $m[2]))
			return mktime(0, 0, 0, $m[1], $m[0], $m[2]);
	}
	trigger_error("Το '<b>$a</b>' δεν είναι ημερομηνία στη μορφή π.χ. '20 Μαρ 19'");
}

/** Παίρνει μια ταυτότητα σύμβασης ή τιμολογίου και επιστρέφει το timestamp της.
 * @param string $a Ταυτότητα της μορφής '1234/31-12-2019', όπως π.χ. δίνεται μια ταυτότητα
 * τιμολογίου ή σύμβασης
 * @return array|null Το πρώτο στοιχείο είναι το timestamp της ημερομηνίας και τα υπόλοιπα, οι
 * παρενθέσεις του regular expression. Επιστρέφεται null αν η ταυτότητα δεν είναι έγκυρη. */
function get_timestamp_from_date2($a) {
	$m = null;
	if (preg_match('/(\d+)\/(\d{1,2})-(\d{1,2})-(\d{4})/', $a, $m)
			&& $m[4] >= 2000 && $m[4] < date('Y') + 3 && checkdate($m[3], $m[2], $m[4])) {
		$m[0] = mktime(0, 0, 0, $m[3], $m[2], $m[4]);
		return $m;
	}
}

/** Ελέγχει την ορθότητα της ταυτότητας ενός στρατιωτικού εγγράφου.
 * Αν η ταυτότητα του εγγράφου δεν είναι ορθή, το πρόγραμμα τερματίζει με ένα μήνυμα σφάλματος.
 * @param string $order Η ταυτότητα του εγγράφου */
function explode_order(& $order) {
	$a = null;
	if (preg_match('/^(Φ\.?\d{3}(\.\d+)?)\/(\d+)\/(\d+)\/(Σ\.?\d+)\/(\d{1,2} (Ιαν|Φεβ|Μαρ|Μάρ|Απρ|Μαι|Μάι|Ιουν|Ιούν|Ιουλ|Ιούλ|Αυγ|Αύγ|Σεπ|Οκτ|Νοε|Νοέ|Δεκ) (\d{2}))\/([^\\\{\}\:]+)( \(ΑΔΑ\: ?([Α-Ω0-9]{5}-[Α-Ω0-9]{3}), ΑΔΑΜ\: ?([Α-ΩA-Z0-9]{14})\))?$/', $order, $a)) {
		$order = array(
			'Ταυτότητα' => $a[0],
			'Φάκελος - Πρωτόκολλο' => "{$a[1]}/{$a[3]}/{$a[4]}", 'Σχέδιο' => $a[5],
			'Ημερομηνία' => $a[6], 'Timestamp' => get_timestamp_from_date($a[6]), 'Εκδότης' => $a[9]
		);
		if (isset($a[12])) { $order['ΑΔΑ'] = $a[11]; $order['ΑΔΑΜ'] = $a[12]; }
	} else
		trigger_error(($order ? "Το '<b>$order</b>' δεν είναι ταυτότητα στρατιωτικού εγγράφου"
			: 'Η ταυτότητα στρατιωτικού εγγράφου πρέπει να δίνεται')
			. ' στη μορφή Φ.800.12/23/1234/Σ.123/31 Μαρ 19/3 ΛΜΧ/4ο Γρ. <i>(ΑΔΑ: ΑΒΓ12-1ΔΕ, ΑΔΑΜ: 19REQ123456789)</i>', E_USER_ERROR);
}

/** Ελέγχει την ορθότητα της ταυτότητας ενός στρατιωτικού εγγράφου, αν υπάρχει.
 * Αν η ταυτότητα του εγγράφου υπάρχει και δεν είναι ορθή, το πρόγραμμα τερματίζει με ένα μήνυμα
 * σφάλματος.
 * @param array $ar Ένα array με κάποιο στοιχείο του να είναι η ταυτότητα του στρατιωτικού εγγράφου
 * @param string|int $key Το κλειδί του στοιχείου του array */
function explode_order_if_exists(& $ar, $key) {
	if (isset($ar[$key])) explode_order($ar[$key]);
}

/** Χωρίζει ένα κείμενο με βάση κάποιο άλλο κείμενο.
 * @param string $s Το κείμενο που θα κομματιαστεί
 * @param string $c Το κείμενο που σηματοδοτεί ένα νέο κόμματι
 * @return array Τα τμήματα που προέκυψαν από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους */
function explodetrim($s, $c) { return array_map(function($a) { return trim($a); }, explode($c, $s)); }

/** Χωρίζει ένα κείμενο με βάση το χαρακτήρα '&'.
 * @param string $s Το κείμενο που θα κομματιαστεί. Επιστρέφεται array με τα τμήματα που προέκυψαν
 * από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους */
function explode_string(& $s) { $s = explodetrim($s, '&'); }

/** Χωρίζει ένα κείμενο με βάση το χαρακτήρα '&'.
 * Με την επιστροφή της συνάρτησης το στοιχείο $ar[$key] έχει το array με τα τμήματα που προέκυψαν
 * από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους.
 * @param array $ar Ένα array με κάποιο στοιχείο του να είναι το κείμενο που θα κομματιαστεί
 * @param string|int $key Το κλειδί του στοιχείου του array */
function explode_string_if_exists(& $ar, $key) {
	if (isset($ar[$key])) $ar[$key] = explodetrim($ar[$key], '&');
}


// ------------------------------------------------------------------------ ΒΗΜΑΤΑ ΑΡΧΙΚΟΠΟΙΗΣΗΣ ---

/** Κρίσιμες ρυθμίσεις για την εκτέλεση του PHP.
 * Επίπεδο αρχικοποίησης 1. */
function init_php() {
	set_time_limit(10);
	date_default_timezone_set('Europe/Athens');
	setlocale(LC_ALL, 'el_GR', 'ell_grc');
}

/** Η επικεφαλίδα του RTF αρχείου.
 * Επίπεδο αρχικοποίησης 1. */
function rtf_header() {
?>{\rtf1\ansicpg1253\deff0\deflang1032

{\fonttbl
{\f0\fswiss\fcharset161 Arial;}
}

{\colortbl;
\red240\green240\blue240;
}

{\info
{\manager Γκέσος Παύλος}
{\company Ελληνικός Στρατός}
{\doccomm Δημιουργήθηκε από το πρόγραμμα «Στρατιωτικές Δαπάνες» του Παύλου Γκέσου}
}

\deftab567
\hyphauto1
\ftnbj


<?php }

/** Ο χειριστής σφάλματος του PHP.
 * Επίπεδο αρχικοποίησης 2. */
function init_error_handler() {
	/** Θέτει το χειριστή σφαλμάτων και προειδοποιήσεων για τη μηχανή PHP.
	 * Αν επιστρέψει το callback, ο χειρισμός του σφάλματος πραγματοποιείται από τον προκαθορισμένο
	 * χειριστή σφάλματος του PHP.
	 * <p>Ο λόγος ύπαρξης του χειριστή, είναι προκειμένου να αντικαθιστά τυχόν σφάλματα του PHP με
	 * ελληνικό, πιο επεξηγηματικό κείμενο, καθώς το κείμενο αυτό θα το δει ο πελάτης και θα πρέπει
	 * να καταλάβει τι έκανε λάθος ή τι παρέλειψε.
	 * @param int $errno Ο τύπος του σφάλματος
	 * @param string $str Το μήνυμα του σφάλματος
	 * @param string $file Το αρχείο στο οποίο συνέβη το σφάλμα
	 * @param int $line Η γραμμή στο αρχείο στο οποίο συνέβη το σφάλμα */
	set_error_handler(function($errno, $str, $file, $line) {
		if ($errno == E_STRICT) return;

		// Εμφάνιση του μυνήματος λάθους όσο γίνεται πιο ανθρώπινα
		$str = str_replace('Undefined index:', 'Δεν ορίστηκε το πεδίο <b>', $str);
		$file = basename($file, '.php');
		fwrite(STDERR, "<html><b>$file($line):</b> $str\n");

		if ($errno == E_USER_ERROR) die();
	});
}

/** Δημιουργία των δεδομένων από το stdin stream.
 * Επίπεδο αρχικοποίησης 3. */
function init_unserialize() {
	global $data;
	// Μετατροπή του κειμένου στο STDIN στην κύρια δομή δεδομένων
	$data = unserialize(stream_get_contents(STDIN));
	if (!$data) trigger_error('Τα εισερχόμενα δεδομένα είναι λάθος', E_USER_ERROR);
}

/** Ενσωματώνει στα δεδομένα, λίστα με τα ονόματα όλων των επιμέρους κρατήσεων, όλων των τιμολογίων.
 * Μια λίστα με τα ονόματα όλων των επιμέρους κρατήσεων όλων των τιμολογίων αποθηκεύεται στο πεδίο
 * $data['Κρατήσεις']. */
function init_deduction_names() {
	global $data;
	$a = array();
	foreach($data['Τιμολόγια'] as $invoice) {
		$deduction = $invoice['Κρατήσεις'];
		if ($deduction)
			foreach(array_keys($deduction) as $v)
				if (!in_array($v, $a)) $a[] = $v;
	}
	$data['Κρατήσεις'] = $a;
}

/** Προετοιμάζει τους διαγωνισμούς.
 * Ελέγχει οι διαγωνιζόμενοι να είναι τουλάχιστον τρείς.
 * <p>Ορίζει το timestamp της έναρξης του διαγωνισμού από το χρόνο έναρξης του διαγωνισμού.
 * <p>Ορίζει τον τίτλο του διαγωνισμού, αν δεν έχει οριστεί, από τον τίτλο της δαπάνης. */
function init_tenders() {
	global $data;
	if (!isset($data['Διαγωνισμοί'])) return;
	foreach($data['Διαγωνισμοί'] as & $tender) {
		// Οι διαταγές σπάνε
		explode_order_if_exists($tender, 'Διακήρυξη Διαγωνισμού');
		explode_order_if_exists($tender, 'Απόφαση Ανάδειξης Προσωρινού Αναδόχου');
		explode_order_if_exists($tender, 'Κατακύρωση Διαγωνισμού');
		// Τα κενά πεδία των διαγωνισμών συμπληρώνονται
		if (!isset($tender['Τίτλος'])) $tender['Τίτλος'] = $data['Τίτλος'];
		//Timestamps
		make_timestamp_if_exists($tender, 'Χρόνος Αποσφράγισης Προσφορών');
		make_timestamp_if_exists($tender, 'Χρόνος Αποσφράγισης Οικονομικών Προσφορών');
		make_timestamp_if_exists($tender, 'Χρόνος Κατάθεσης Δικαιολογητικών Κατακύρωσης');
		// Τα δικαιολογητικά διαχωρίζονται
		explode_string_if_exists($tender, 'Δικαιολογητικά Συμμετοχής');
		explode_string_if_exists($tender, 'Δικαιολογητικά Κατακύρωσης');
		// Για κάθε ενδιαφερόμενο
		foreach($tender['Ενδιαφερόμενοι'] as & $competitor) {
			// Τα δικαιολογητικά διαχωρίζονται
			explode_string_if_exists($competitor, 'Δικαιολογητικά Συμμετοχής');
			explode_string_if_exists($competitor, 'Λόγοι Απόρριψης Συμμετοχής');
			// Ξεκαθαρίζεται αν υπέβαλαν οικονομική προσφορά έγκυρη ή απορρίφθηκε
			if (isset($competitor['Προσφορά ή Απόρριψη'])) {
				$m = $competitor['Προσφορά ή Απόρριψη'];
				if (is_numeric($m)) $competitor['Προσφορά'] = $m;
				else $competitor['Λόγοι Απόρριψης Οικονομικής Προσφοράς'] = explodetrim($m, '&');
				unset($competitor['Προσφορά ή Απόρριψη']);
			}
		}
		unset($competitor);	// foreach by ref απαιτείται
		// Φιλτράρισμα ενδιαφερόμενων σε εγκεκριμένους και απορριφθέντες
		$tender['Απορριφθέντες Α'] = $tender['Προκριθέντες Α'] = $tender['Απορριφθέντες Β'] = $tender['Προκριθέντες Β'] = array();
		foreach($tender['Ενδιαφερόμενοι'] as $competitor) {
			$a = isset($competitor['Λόγοι Απόρριψης Συμμετοχής']) ? 'Απορριφθέντες' : 'Προκριθέντες';
			$tender["$a Α"][] = $competitor;
		}
		foreach($tender['Προκριθέντες Α'] as $competitor) {
			$a = isset($competitor['Λόγοι Απόρριψης Οικονομικής Προσφοράς']) ? 'Απορριφθέντες' : 'Προκριθέντες';
			$tender["$a Β"][] = $competitor;
		}
		$tender['Απορριφθέντες'] = array_merge($tender['Απορριφθέντες Α'], $tender['Απορριφθέντες Β']);
		// Υπολογισμός μειοδοτών. Έχει εφαρμογή μόνο αν ο διαγωνισμός δεν γίνεται κατά είδος.
		// Αν οι μειοδότες είναι πάνω από ένας (έχουν δώσει ίδια τιμή) ο διαγωνισμός πρέπει να επαναληφθεί.
		if (!$tender['Προσφορά κατά είδος']) {
			$min = min(array_map(function($i) { return isset($i['Προσφορά']) ? $i['Προσφορά'] : 0; }, $tender['Προκριθέντες Β']));
			if ($min)	// Σε περίπτωση εξαγωγής διακήρυξης, δε μας αφορά και δε συμπληρώνεται
				$tender['Μειοδότες'] = array_values(array_filter($tender['Προκριθέντες Β'],
						function($i) use($min) { return $i['Προσφορά'] == $min; }));
		}
	}
}

/** Προετοιμάζει τις συμβάσεις.
 * Σε διαγωνισμούς, ο νικητής ορίζεται με index στη λίστα διαγωνιζόμενων. Αυτό απαιτεί τροποποίηση.
 * <p>Ορίζει τον τίτλο της σύμβασης αν δεν έχει τεθεί, πρώτα από τον τίτλο του διαγωνισμού στον
 * οποίο ανήκει η σύμβαση (αν ανήκει) και αν δεν έχει οριστεί ούτε αυτός, από τον τίτλο της δαπάνης.
 * <p>Πρέπει να κληθεί μετά από την init_tenders(). */
function init_contracts() {
	global $data;
	if (!isset($data['Συμβάσεις'])) return;
	foreach($data['Συμβάσεις'] as & $contract) {
		$title = $data['Τίτλος'];		// fallback 2 για τον τίτλο της σύμβασης
		if (isset($contract['Διαγωνισμός'])) {
			$tender = $contract['Διαγωνισμός'] = $data['Διαγωνισμοί'][$contract['Διαγωνισμός']];
			$title = $tender['Τίτλος']; // fallback 1 για τον τίτλο της σύμβασης
			// Σε διαγωνισμό, ο δικαιούχος αποθηκευέται σαν index
			if (isset($contract['Ανάδοχος']))
				$contract['Ανάδοχος'] = $tender['Ενδιαφερόμενοι'][$contract['Ανάδοχος']]['Ενδιαφερόμενος'];
		}
		// Τα κενά πεδία των συμβάσεων συμπληρώνονται
		if (!isset($contract['Τίτλος'])) $contract['Τίτλος'] = $title;
		// Ελέγχει την ταυτότητα μιας σύμβασης η οποία πρέπει να είναι στη μορφή '1234/31-12-2019'.
		// Αν η ταυτότητα της σύμβασης είναι έγκυρη, τότε η μορφή της γίνεται '1234/2019' δηλαδή
		// 'αρ. πρωτοκόλου'/'έτος'. Επίσης υπολογίζεται το timestamp της σύμβασης.
		if (isset($contract['Σύμβαση'])) {
			$a = get_timestamp_from_date2($contract['Σύμβαση']);
			if (isset($a)) {
				$contract['Ημερομηνία'] = $a[0];
				$contract['Σύμβαση'] = "{$a[1]}/{$a[4]}";
			} else unset($contract['Σύμβαση']);//;trigger_error("Η '<b>{$contract['Σύμβαση']}</b>' δεν είναι ταυτότητα σύμβασης στη μορφή 1324/31-12-2006 (αρ. πρωτοκόλλου/ημερομηνία)");
		}
	}
}

/** Ενσωματώνει στα τιμολόγια τις αξίες του τιμολογίου.
 * Στο πεδίο 'Τιμές', αποθηκεύεται ένα array με στοιχεία που έχουν κλειδιά 'Καθαρή Αξία', 'ΦΠΑ',
 * 'Καταλογιστέο', 'Κρατήσεις', 'Πληρωτέο', 'Καθαρή Αξία για ΦΕ', 'ΦΕ', 'Υπόλοιπο Πληρωτέο', με την
 * αντίστοιχη τιμή για το καθένα.
 * <p>Το παραπάνω συμβαίνει και στο πεδίο $data['Τιμές'], αθροιστικά για όλα τα τιμολόγια.
 * <p>Στο πεδίο 'Κατηγορίες ΦΠΑ' αποθηκεύονται ως κλειδιά τα διαφορετικά ποσοστά ΦΠΑ του τιμολογίου
 * και ως τιμές, οι αντίστοιχες αξίες του ΦΠΑ σε €.
 * <p>Αν το τιμολόγιο ανήκει σε σύμβαση, στο πεδίο 'Δικαιούχος', αποθηκεύεται το πεδίο 'Ανάδοχος'
 * της σύμβασης.
 * <p>Στα είδη τιμολογίου, στο πεδίο 'Συνολική Τιμή', αποθηκεύεται το γινόμενο ποσότητας είδους επί
 * της καθαρής αξίας του ενός είδους.
 * <p>Στις κρατήσεις, στο πεδίο 'Σύνολο', αποθηκεύεται το σύνολο των επιμέρους κρατήσεων της κράτησης.
 * <p>Πρέπει να κληθεί μετά από την init_deduction_names() και την init_contracts(). */
function init_invoices() {
	global $data;
	foreach($data['Τιμολόγια'] as & $invoice) {
		// Ελέγχει την ταυτότητα ενός τιμολογίου που πρέπει να έχει τη μορφή 1234/31-12-2019 και
		// προσθέτει στα στοιχεία του τιμολογίου το timestamp του τιμολογίου.
		if (isset($invoice['Τιμολόγιο'])) {
			$a = get_timestamp_from_date2($invoice['Τιμολόγιο']);
			if (isset($a)) $invoice['Ημερομηνία'] = $a[0];
			else trigger_error("Το '<b>{$invoice['Τιμολόγιο']}</b>' δεν είναι ταυτότητα τιμολογίου στη μορφή 1324/31-12-2006");
		}
		// Αρχικοποιεί σύμβαση και δικαιούχο
		if (isset($invoice['Σύμβαση'])) {
			$invoice['Σύμβαση'] = $data['Συμβάσεις'][$invoice['Σύμβαση']];
			$invoice['Δικαιούχος'] = $invoice['Σύμβαση']['Ανάδοχος'];
		}
		// Ενσωματώνει στις κρατήσεις των τιμολογίων το άθροισμα των επιμέρους κρατήσεών τους.
		$deduction = & $invoice['Κρατήσεις'];
		if (!$deduction) $invoice['Κρατήσεις'] = array('Σύνολο' => 0);
		else {
			$sum = 0;
			foreach($deduction as $v)
				$sum += $v;
			$deduction['Σύνολο'] = round($sum, 5);
		}
		unset($deduction);
		// Ενσωματώνει το πεδίο 'Συνολική Τιμή' σε κάθε είδος τιμολογίου
		// Υπολογίζει καθαρή αξία και ΦΠΑ τιμολογίου καθώς και τυχόν κατηγορίες ΦΠΑ
		$net = $vat = 0;
		$vat_categories = array();
		foreach($invoice['Είδη'] as & $item) {
			$a = round($item['Τιμή Μονάδας'] * $item['Ποσότητα'], 3);
			$item['Συνολική Τιμή'] = $a;
			$net += $a;
			$vat_p = $item['ΦΠΑ'];
			if ($vat_p) {
				$a *= $vat_p / 100;
				$vat += $a;
				if (isset($vat_categories[$vat_p])) $vat_categories[$vat_p] += $a;
				else $vat_categories[$vat_p] = $a;
			}
		}
		unset($item);
		// Ενσωματώνει τις αξίες του τιμολογίου σε κάθε τιμολόγιο
		$net = round($net, 2);
		$vat = round($vat, 2);
		$vat_categories = adjust_partials($vat_categories, $vat);
		$mixed = $net + $vat;
		$deductions = round($net * $invoice['Κρατήσεις']['Σύνολο'] / 100, 2);
		if ($invoice['Δικαιούχος']['Τύπος'] != 'Ιδιωτικός Τομέας') $mixed += $deductions;
		$mixed = round($mixed, 2);
		$payable = round($mixed - $deductions, 2);
		$netIncomeTax = $net;
		$incomeTax = $invoice['ΦΕ'];
		if ($incomeTax != 3) $netIncomeTax -= $deductions;
		$netIncomeTax = round($netIncomeTax, 2);
		$incomeTax = round($netIncomeTax * $incomeTax / 100, 2);
		$payableMinusIncomeTax = round($payable - $incomeTax, 2);
		$invoice['Τιμές'] = array(
			'Καθαρή Αξία'        => $net,
			'ΦΠΑ'                => $vat,
			'Καταλογιστέο'       => $mixed,
			'Κρατήσεις'          => $deductions,
			'Πληρωτέο'           => $payable,
			'Καθαρή Αξία για ΦΕ' => $netIncomeTax,
			'ΦΕ'                 => $incomeTax,
			'Υπόλοιπο Πληρωτέο'  => $payableMinusIncomeTax
		);
		$invoice['Κατηγορίες ΦΠΑ'] = $vat_categories;
	}
	// Υπολογισμός καταλογιστέου, κρατήσεων, ΦΕ, κτλ για το σύνολο της δαπάνης
	$data['Τιμές'] = calc_sum_of_invoices_prices($data['Τιμολόγια']);
	// Ενσωματώνει στο πεδίο $data['Ημερομηνία Τελευταίου Τιμολογίου'] την πιο πρόσφατη ημερομηνία
	// τιμολογίου, σε timestamp.
	$a = get_newer_timestamp($data['Τιμολόγια']);
	if ($a) $data['Ημερομηνία Τελευταίου Τιμολογίου'] = $a;
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων του κάθε δικαιούχου.
 * Στο πεδίο $data['Δικαιούχοι'], αποθηκεύονται στοιχεία για κάθε δικαιούχο.
 * <p>Κάθε στοιχείο δικαιούχου, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια του δικαιούχου.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων του δικαιούχου.
 * <li>Με κλειδί 'Δικαιούχος' τα στοιχεία του δικαιούχου.
 * <li>Με κλειδί 'Σύμβαση' τη σύμβαση με το δικαιούχο, αν υπάρχει.</ul>
 * <p>Επίσης ελέγχει αν τα τιμολόγια του ίδιου δικαιούχου ανήκουν στην ίδια σύμβαση. Αν ένας
 * δικαιούχος έχει υπογράψει σύμβαση μαζί μας, όλα τα τιμολόγια που έχει εκδόσει πρέπει να ανήκουν
 * σε αυτή τη σύμβαση. Αν δεν έχει υπογράψει, δεν πρέπει κανένα τιμολόγιο να ανήκει σε αυτή τη σύμβαση.
 * <p>Πρέπει να κληθεί μετά από την init_invoices(). */
function init_by_contractor() {
	global $data;
	// Τιμολόγια κατά δικαιούχο: Επιστρέφει ένα array με ένα στοιχείο για κάθε δικαιούχο,
	// που περιέχει ένα array με όλα τα τιμολόγια του δικαιούχου
	$b = array();
	foreach($data['Τιμολόγια'] as $invoice)
		$b[$invoice['Δικαιούχος']['Επωνυμία']][] = $invoice;
	$data['Δικαιούχοι'] = array_values($b);
	// Απαρίθμηση του κάθε δικαιούχου για να προστεθούν επιπλέον πεδία
	foreach($data['Δικαιούχοι'] as & $per_contractor) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoice = $per_contractor[0];
		$per_contractor = array(
			'Τιμολόγια' => $per_contractor,
			'Τιμές' => calc_sum_of_invoices_prices($per_contractor),
			'Δικαιούχος' => $invoice['Δικαιούχος']);
		// Δημιουργεί συντόμευση σύμβασης, αν υπάρχει, από το πρώτο τιμολόγιο, και επιπλέον...
		if (isset($invoice['Σύμβαση'])) {
			$contract = $per_contractor['Σύμβαση'] = $invoice['Σύμβαση'];
			// ...όλα τα τιμολόγια του ίδιου δικαιούχου πρέπει να έχουν την ίδια σύμβαση
			foreach($per_contractor['Τιμολόγια'] as $invoice)
				if (!isset($invoice['Σύμβαση']) || $contract !== $invoice['Σύμβαση'])
					trigger_error("Δεν ανήκουν όλα τα τιμολόγια του «{$invoice['Δικαιούχος']['Επωνυμία']}» στην ίδια σύμβαση");
		} else	// Αν δεν υπάρχει σύμβαση στο πρώτο τιμολόγιο, κανένα τιμολόγιο δεν πρέπει να έχει
			foreach($per_contractor['Τιμολόγια'] as $invoice)
				if (isset($invoice['Σύμβαση']))
					trigger_error("Δεν ανήκουν όλα τα τιμολόγια του «{$invoice['Δικαιούχος']['Επωνυμία']}» στην ίδια σύμβαση");
	}
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων της κάθε σύμβασης.
 * Στο πεδίο $data['Συμβάσεις'], αποθηκεύονται στοιχεία για κάθε σύμβαση.
 * <p>Κάθε στοιχείο σύμβασης, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια της σύμβασης.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων της σύμβασης.
 * <li>Με κλειδί 'Δικαιούχος' τα στοιχεία του δικαιούχου.
 * <li>Με κλειδί 'Σύμβαση' τη σύμβαση με το δικαιούχο.
 * <li>Με κλειδί 'Διαγωνισμός' το διαγωνισμό στον οποίο ανήκει η σύμβαση, αν ανήκει.</ul>
 * <p>Επίσης ελέγχει αν υπάρχουν συμβάσεις δίχως τιμολόγια.
 * <p>Πρέπει να κληθεί μετά από την init_invoices(). */
function init_by_contract() {
	global $data;
	if (!isset($data['Συμβάσεις'])) return;
	// Τιμολόγια κατά σύμβαση: Επιστρέφει ένα array με ένα στοιχείο για κάθε σύμβαση, που περιέχει
	// ένα array με όλα τα τιμολόγια της σύμβασης
	$contracts = array();
	foreach($data['Τιμολόγια'] as $invoice)
		if (isset($invoice['Σύμβαση'])) {
			// Δυστυχώς δεν μπορούν να υπάρξουν array ως κλειδιά
			// Έλεγχος αν υπάρχει η σύμβαση.
			foreach($contracts as & $per_contract)
				if ($per_contract[0]['Σύμβαση'] == $invoice['Σύμβαση']) {
					$per_contract[] = $invoice;
					continue 2;
				}
			// Δε βρέθηκε ομάδα τιμολογίων γι' αυτή τη σύμβαση
			$contracts[][] = $invoice;
		}
	// Απαρίθμηση της κάθε σύμβασης για να προστεθούν επιπλέον πεδία
	foreach($contracts as & $per_contract) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoice = $per_contract[0];
		$contract = $invoice['Σύμβαση'];
		$contractor = $invoice['Δικαιούχος'];
		$per_contract = array(
			'Τιμολόγια' => $per_contract,
			'Τιμές' => calc_sum_of_invoices_prices($per_contract),
			'Δικαιούχος' => $contractor,
			'Σύμβαση' => $contract);
		// Η κατηγορία της σύμβασης (Έργο, Προμήθεια, Υπηρεσία)
		$per_contract['Κατηγορία'] = get_invoices_category($per_contract['Τιμολόγια']);
		if (isset($contract['Διαγωνισμός'])) {
			// Δημιουργεί συντόμευση διαγωνισμού, αν υπάρχει
			$per_contract['Διαγωνισμός'] = $tender = $contract['Διαγωνισμός'];
			// Η οικονομικότερη προσφορά στο διαγωνισμό πρέπει να συμπίπτει με το καταλογιστέο της
			// σύμβασης και ο ενδιαφερόμενος που την κάνει πρέπει να είναι ο ανάδοχος της σύμβασης
			// Αν όμως εξάγουμε διακήρυξη διαγωνισμού, όλα αυτά δεν απαιτούνται ακόμα
			if (!$tender['Προσφορά κατά είδος'] && isset($tender['Μειοδότες'])) {
				$competitors = $tender['Μειοδότες'];
				if (count($competitors)) {
					$contractors = array_map(function($i) { return $i['Ενδιαφερόμενος']; }, $competitors);
					if (!in_array($contractor, $contractors))
						trigger_error('Ανάδοχος δεν έχει τη χαμηλότερη προσφορά στο διαγωνισμό');
					if ($competitors[0]['Προσφορά'] != $per_contract['Τιμές']['Καταλογιστέο'])
						trigger_error('Προσφορά αναδόχου δε συμπίπτει με το καταλογιστέο της σύμβασης');
				}
			}
		}
	}
	// Πρέπει όλες οι συμβάσεις να χρησιμοποιούνται απο τιμολόγια
	if (count($contracts) != count($data['Συμβάσεις']))
		trigger_error('Υπάρχουν συμβάσεις που δεν χρησιμοποιούνται από κανένα τιμολόγιο');
	// Απόδοση των δεδομένων
	$data['Συμβάσεις'] = $contracts;
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων και συμβάσεων του κάθε διαγωνισμού.
 * Στο πεδίο $data['Διαγωνισμοί'], αποθηκεύονται στοιχεία για κάθε διαγωνισμό.
 * <p>Κάθε στοιχείο διαγωνισμού, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια του διαγωνισμού.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων του διαγωνισμού.
 * <li>Με κλειδί 'Συμβάσεις' τις συμβάσεις που προέκυψαν από το διαγωνισμό.
 * <li>Με κλειδί 'Διαγωνισμός' το διαγωνισμό.</ul>
 * <p>Επίσης ελέγχει αν υπάρχουν διαγωνισμοί δίχως συμβάσεις.
 * <p>Πρέπει να κληθεί μετά από την init_by_contract(). */
function init_by_tender() {
	global $data;
	if (!isset($data['Διαγωνισμοί'])) return;
	// Συμβάσεις κατά διαγωνισμό: Επιστρέφει ένα array με ένα στοιχείο για κάθε διαγωνισμό, που
	// περιέχει ένα array με όλες τις συμβάσεις του διαγωνισμού
	$tenders = array();
	foreach($data['Συμβάσεις'] as $per_contract)
		if (isset($per_contract['Διαγωνισμός'])) {
			// Δυστυχώς δεν μπορούν να υπάρξουν array ως κλειδιά
			// Έλεγχος αν υπάρχει ο διαγωνισμός.
			foreach($tenders as & $per_tender)
				if ($per_tender[0]['Διαγωνισμός'] == $per_contract['Διαγωνισμός']) {
					$per_tender[] = $per_contract;
					continue 2;
				}
			// Δε βρέθηκε ο διαγωνισμός
			$tenders[][] = $per_contract;
		}
	// Απαρίθμηση του κάθε διαγωνισμού για να προστεθούν επιπλέον πεδία
	foreach($tenders as & $per_tender) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoices = array_reduce($per_tender, function($p, $i) { return array_merge($p, $i['Τιμολόγια']); }, array());
		$contracts = array_map(function($a) { return $a['Σύμβαση']; }, $per_tender);
		$per_tender = array(
			'Τιμολόγια' => $invoices,
			'Συμβάσεις' => $contracts,
			'Διαγωνισμός' => $contracts[0]['Διαγωνισμός']);
		// Timestamp νεότερης σύμβασης
		$a = get_newer_timestamp($contracts);
		if (isset($a)) $per_tender['Χρόνος Υπογραφής Συμβάσεων'] = $a;
		// Η κατηγορία του διαγωνισμού (Έργο, Προμήθεια, Υπηρεσία)
		$per_tender['Κατηγορία'] = get_invoices_category($per_tender['Τιμολόγια']);
		// Διαγωνισμοί με περισσότερες τις μια συμβάσεις, πρέπει να είναι κατά είδος
		if (count($contracts) > 1 && !$per_tender['Διαγωνισμός']['Προσφορά κατά είδος'])
			trigger_error('Διαγωνισμός με πάνω από μια σύμβαση, χωρίς "Προσφορά κατά είδος"');
	}
	// Πρέπει όλοι οι διαγωνισμοί να χρησιμοποιούνται απο συμβάσεις
	if (count($tenders) != count($data['Διαγωνισμοί']))
		trigger_error('Υπάρχουν διαγωνισμοί που δεν χρησιμοποιούνται από καμία σύμβαση');
	// Απόδοση των δεδομένων
	$data['Διαγωνισμοί'] = $tenders;
}

/** Αρχικοποίηση του PHP αλλά και της αρχικής δομής της δαπάνης.
 * @param int $i Επίπεδο αρχικοποίησης. */
function init($i) {
	global $data, $init;
	while($init < $i)
		switch(++$init) {
			case 1: init_php(); rtf_header(); break;
			case 2: init_error_handler(); break;
			case 3: init_unserialize(); break;
			case 4:
				explode_order_if_exists($data, 'Απόφαση Ανάληψης Υποχρέωσης');
				explode_order_if_exists($data, 'Απόφαση Απευθείας Ανάθεσης');
				explode_order_if_exists($data, 'Διαβιβαστικό Δαπάνης');
				explode_order_if_exists($data, 'Δγη Συγκρότησης Επιτροπών');
				break;
			case 5:
				init_deduction_names();
				init_tenders();
				init_contracts();
				init_invoices();
				break;
			case 6: init_by_contractor(); break;
			case 7: init_by_contract(); break;
			case 8: init_by_tender(); break;
		}
}